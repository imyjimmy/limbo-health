# Commit Message Lifecycle

## Purpose
Document how Git commit messages are produced in Limbo Health, since users do not type commit messages directly in the product UI.

## Core Rule
Commit messages are generated by application workflows, not by explicit user input fields.

In practice:
1. A feature flow chooses a message template string from action context.
2. The Git layer commits that message (plaintext or encrypted, depending on the flow).
3. The server stores exactly what the client pushed.

## Frontend (Web) Flow
Primary implementation:
1. `/Users/imyjimmy/dev/pleb-emr/limbo-health/apps/frontend/src/lib/encryptedGit.ts`

Behavior:
1. `commitEncrypted(...)` accepts a semantic message string from caller context.
2. It encrypts that message with NIP-44 before calling `git.commit(...)`.
3. `getCommitLog(...)` decrypts stored commit messages for display.

Message source examples:
1. "Initial encrypted medical history" during binder creation.
2. "Added note: ..." during note save flows.

## React Native Flow
Primary implementation:
1. `/Users/imyjimmy/dev/pleb-emr/limbo-health/apps/react-native/core/git/GitEngine.ts`
2. `/Users/imyjimmy/dev/pleb-emr/limbo-health/apps/react-native/core/binder/BinderService.ts`
3. `/Users/imyjimmy/dev/pleb-emr/limbo-health/apps/react-native/core/scan/StagingRepo.ts`

Behavior:
1. `BinderService` and scan orchestration generate message templates from app actions.
2. `GitEngine` passes those strings into `git.commit(...)`.
3. There is no user-facing "commit message" input in normal app UX.

Message source examples:
1. `Initialize binder`
2. `Add ${category} entry`
3. `Update ${doc.metadata.type} entry`
4. `Delete ...`
5. `Shared medical records` (staging/share flow)

## Why This Matters
If server policy requires encrypted commit messages (for example on `codex/naive-git-server`), every commit-producing client path must comply.

Because commit messages are system-generated:
1. Compliance is an implementation concern, not a user training concern.
2. Any new commit call site must follow the same message policy.

## Maintenance Checklist
When adding or changing a write flow:
1. Find where the semantic message string is created.
2. Confirm the message path is policy-compliant before `git.commit(...)`.
3. Add/update tests for that flow so regressions are caught automatically.
